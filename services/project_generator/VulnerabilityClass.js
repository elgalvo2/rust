import {v4 as uuidv4} from 'uuid'
import fs from 'fs'
const fsPromises = fs.promises

// la forma en la que se actualiza el directorio de vulnerabilidades es ineficiente debido a la asincornidad... deberia de refactorizarse
// una solucion podria ser escribir el type_no de cada vulnerabilidad ya que se hayan construido todas las vulnerabilidades del proyecto

class Vulnerability{ // this clase recontruct the info od certain vulnerability
    constructor(words_arr){ // recibes the array that contains certain vulnerability's information
        this.vul_id = uuidv4();
        this.word_arr = words_arr.map(word=>{
            let word_ = {...word}
            word_.text = word.R[0].T.trim()
            delete word_.R
            return word_
        });
        // this.vul_dir_path = project_pdf_path
        this.vul_dir= {}
        this.type_no = 0 // type number described in dict
        this.vul_name = ''
        this.severity = ''
        this.root_file = []
        this.affected_file = []
        this.root_line = []
        this.affected_line = []
        this.root_object = []
        this.affected_object = []
        this.root_method = ''
        this.root_line_code = ''
        this.mitigable = false
    }

    getter(){
        return {
            _id:this.vul_id,
            name:this.vul_name,
            type_no:this.type_no,
            root_file:this.root_file.join(""),
            affected_file:this.affected_file.join(""),
            root_line:this.root_line.join(""),
            affected_line:this.affected_line.join(""),
            root_object:this.root_object.join(""),
            affected_object:this.affected_object.join("")
        }
    }

    async main(){
        // get vulnerability name
        this.vul_name = this.found_text_in_same_row(this.word_arr[0])
        // format vul. name
        this.format_vul_name()
        // gets the vulnerability type
        // await this.set_vul_type()
        this.getTableInfo()
        this.format_file_paths()

        return this.getter()

    }



    format_file_paths(){ // eliminar la raiz del directorio del proyecto
        this.affected_file = this.affected_file.join("").split("%2F").slice(1)
        this.root_file = this.root_file.join("").split("%2F").slice(1)
    }

    getTableInfo(){ // obtener los archivos involucrados en la vulnerabilidad
        // es necesario obtener las coordenadas de los bordes de la tabla que contiene los
        // datos de origen destino, archivo, linea objeto

        // obtenemos los indices de los elementos archivo, linea y objeto-> los rangos de las coordenadas se guardan en objetos y estos en un arreglo
        let rows_arr = []
        let column_arr = []
        let i = 0
        
        while (rows_arr.length < 4 && column_arr.length < 3) {
            
            if((this.word_arr[i].text === 'Archivo' || this.word_arr[i].text === "L%C3%ADnea" || this.word_arr[i].text === "Objeto" || this.word_arr[i].text === "Fragmento" ) && this.word_arr[i].x===1.625){
                
                rows_arr.push({
                    'text':this.word_arr[i].text,
                    'x':this.word_arr[i].x,
                    'y':this.word_arr[i].y
                })
            }
            if(this.word_arr[i].text === "Origen" || this.word_arr[i].text === "Destino"){
                
                column_arr.push({
                    'text':this.word_arr[i].text,
                    'x':this.word_arr[i].x,
                    'y':this.word_arr[i].y
                })
            }
            i++
        }
        // acomodamos los valores de los arreglos auxiliares row y columns por coordenadas
        // sort : negative if x<y positive if x>y zero if x=y so...
        rows_arr.sort((a,b)=>{
            return a.y - b.y
        })
        column_arr.sort((a,b)=>{
            return a.y - b.y
        })
        
        // reducimos arreglos para obtener el rango
        let rows_ranges = [[rows_arr[0].y,rows_arr[1].y],[rows_arr[1].y,rows_arr[2].y],[rows_arr[2].y,rows_arr[3].y]]
        let columns_ranges = [[column_arr[0].x,column_arr[1].x],[column_arr[1].x,column_arr[1].x]]
    

        this.word_arr.forEach((word,index)=>{
            if(word.y >= rows_ranges[0][0] && word.y < rows_ranges[0][1] && word.text != "Archivo"){ // obtiene palabras en la fila de "ARchivo"
                if(word.x >= columns_ranges[0][0] && word.x < columns_ranges[0][1]){
                    this.root_file.push(this.decodeText(word.text))
                }
                else{
                    this.affected_file.push(this.decodeText(word.text))
                }
            }

            if(word.y >= rows_ranges[1][0] && word.y < rows_ranges[1][1]  && word.text != "L%C3%ADnea"){ // obtiene palabras en la linea "Linea"
                if(word.x >= columns_ranges[0][0] && word.x < columns_ranges[0][1]){
                    this.root_line.push(this.decodeText(word.text))
                }else{
                    this.affected_line.push(this.decodeText(word.text))
                }
            }

            if(word.y >= rows_ranges[2][0] && word.y < rows_ranges[2][1]  && word.text != "Objeto"){ // obtener palabras en la linea Objeto
                if(word.x >= columns_ranges[0][0] && word.x < columns_ranges[0][1]){
                    this.root_object.push(this.decodeText(word.text))
                }else{
                    this.affected_object.push(this.decodeText(word.text))
                }
            }
        })
    }

    // async set_vul_type(){
    //     this.vul_dir = await fsPromises.readFile(this.vul_dir_path)

    //     this.vul_dir = JSON.parse(this.vul_dir)
    //     let vul_names = Object.keys(this.vul_dir)

    //     if(vul_names.includes(this.vul_name)){
    //         this.type_no = this.vul_dir[this.vul_name]
    //     }else{
    //         this.vul_dir[this.vul_name] = vul_names.length
    //         this.type_no = vul_names.length
    //         await fsPromises.writeFile('./utils/vul_directory.json',JSON.stringify(this.vul_dir))
    //     }
    // }

    // this object finds the text in the same line than a defined word
    found_text_in_same_row(refrence_word){ // reference word
        let found_text = []
        this.word_arr.forEach(word=>{
             if(word.y === refrence_word.y) found_text.push( decodeURI(word.text));
        })
        
        return found_text.join('_')
    }

    format_vul_name(){ // formats the vul name
        this.vul_name = this.vul_name.split('\\')[0].toString()
    }

    decodeText(text){
        return decodeURI(text)
    }

}

export default Vulnerability