import { v4 as uuidv4 } from 'uuid'
import fs from 'fs'
const fsPromises = fs.promises

const parse_dir = {
    "%2C": ",",
    "%3A": ':',
    "%3C": "<",
    "%3E": ">",
    "%2D": "-",
    "%3B": ";",
    "%3D": "=",
    "%3F":"?",
    "\"":"'",
    "\\\\":"\\",
    "_": " ",

}

// la forma en la que se actualiza el directorio de vulnerabilidades es ineficiente debido a la asincornidad... deberia de refactorizarse
// una solucion podria ser escribir el type_no de cada vulnerabilidad ya que se hayan construido todas las vulnerabilidades del proyecto

class Vulnerability { // this clase recontruct the info od certain vulnerability
    constructor(words_arr) { // recibes the array that contains certain vulnerability's information
        this.vul_id = uuidv4();
        this.word_arr = words_arr.map(word => {
            let word_ = { ...word }
            word_.text = word.R[0].T.trim()
            delete word_.R
            return word_
        });
        // this.vul_dir_path = project_pdf_path
        this.vul_dir = {}
        this.type_no = 0 // type number described in dict
        this.vul_name = ''
        this.severity = ''
        this.root_file = []
        this.affected_file = []
        this.root_line = []
        this.affected_line = []
        this.root_object = []
        this.affected_object = []
        this.root_method = ''
        this.root_code_lines = []
        this.mitigable = false
    }

    getter() {
        
        return {
            _id: this.vul_id,
            name: this.vul_name,
            type_no: this.type_no,
            root_file: this.root_file.join(""),
            affected_file: this.affected_file.join(""),
            root_line: this.root_line.join(""),
            affected_line: this.affected_line.join(""),
            root_object: this.parseStrings(this.root_object.join(""),parse_dir),
            affected_object: this.affected_object.join(""),
            root_method: this.parseStrings(this.root_method, parse_dir),
            root_vulnerability_lines: this.root_code_lines


        }
    }

    async main() {
        // get vulnerability name
        this.vul_name = this.found_text_in_same_row(this.word_arr[0])
        // format vul. name
        this.format_vul_name()
        // gets the vulnerability type
        // await this.set_vul_type()
        this.getInfo()
        this.format_file_paths()

       this.format_root_vul_lines()



        return this.getter()

    }

    format_root_vul_lines() {


        this.root_code_lines = this.root_code_lines.map((vul) => {

            return this.parseStrings(vul, parse_dir)
        })

    }

    parseStrings(text, dir) {
        let r_text = text
        let p_dir = Object.entries(dir)
        let l_dir = p_dir.length

        for (let i = 0; i < l_dir; i++) {
            let key = p_dir[i][0]
            let value = p_dir[i][1]
            
            r_text = r_text.replaceAll(key, value);
        }

        return r_text
    }


    format_file_paths() { // eliminar la raiz del directorio del proyecto
        this.affected_file = this.affected_file.join("").split("%2F").slice(1)
        this.root_file = this.root_file.join("").split("%2F").slice(1)
    }

    getInfo() { // obtener los archivos involucrados en la vulnerabilidad
        // es necesario obtener las coordenadas de los bordes de la tabla que contiene los
        // datos de origen destino, archivo, linea objeto
        
        // obtenemos los indices de los elementos archivo, linea y objeto-> los rangos de las coordenadas se guardan en objetos y estos en un arreglo
        let rows_arr = []
        let column_arr = []
        let root_method_index = undefined
        let above_code_lines_dots = []
        let i = 0
        let aux_between_range = true
        //Aqui se obtienen las palabras de referencia
        while (i <= this.word_arr.length - 1) {


            if (this.word_arr[i].text === "....") {

                above_code_lines_dots.push({
                    'text': this.word_arr[i].text,
                    'x': this.word_arr[i].x,
                    'y': this.word_arr[i].y
                })
            }

            if (this.word_arr[i].text === 'M%C3%A9todo' && this.word_arr[i].x === 1.625) {

                this.root_method = this.found_text_in_same_row(this.word_arr[i], true, "....");
                


            }


            if ((this.word_arr[i].text === 'Archivo' || this.word_arr[i].text === "L%C3%ADnea" || this.word_arr[i].text === "Objeto" || this.word_arr[i].text === "Fragmento") && this.word_arr[i].x === 1.625) {

                rows_arr.push({
                    'text': this.word_arr[i].text,
                    'x': this.word_arr[i].x,
                    'y': this.word_arr[i].y
                })
            }



            if (this.word_arr[i].text === "Origen" || this.word_arr[i].text === "Destino") {

                column_arr.push({
                    'text': this.word_arr[i].text,
                    'x': this.word_arr[i].x,
                    'y': this.word_arr[i].y
                })
            }

            i++
        }

        // this.root_method = this.found_text_in_same_row(this.word_arr[root_method_index])
        // acomodamos los valores de los arreglos auxiliares row y columns por coordenadas
        // sort : negative if x<y positive if x>y zero if x=y so...
        rows_arr.sort((a, b) => {
            return a.y - b.y
        })
        column_arr.sort((a, b) => {
            return a.y - b.y
        })

        // reducimos arreglos para obtener el rango
        let rows_ranges = [[rows_arr[0].y, rows_arr[1].y], [rows_arr[1].y, rows_arr[2].y], [rows_arr[2].y, rows_arr[3].y]]
        let columns_ranges = [[column_arr[0].x, column_arr[1].x], [column_arr[1].x, column_arr[1].x]]



        this.word_arr.forEach((word, index) => {
            let saved_lines = 0


            if (word.y > above_code_lines_dots[0].y && word.x >= above_code_lines_dots[0].x && word.text !== "....") {
                if (word.x === above_code_lines_dots[0].x) {

                    let fc = word.text.split('')
                    if (!isNaN(fc[0])) {

                        this.root_code_lines.push(this.found_text_in_same_row(word))

                    } else {

                        //this.root_code_lines[saved_lines] += this.root_code_lines[-1] + this.found_text_in_same_row(word)
                        this.root_code_lines[saved_lines] +=  this.found_text_in_same_row(word)
                    }
                    // let char_arr = this.root_code_lines[-1].split('')
                    // console.log(isNaN(char_arr[0]))
                    // console.log((char_arr[0]))

                    // if(isNaN(char_arr[0])){
                    //     console.log('entra aqui')
                    //     this.root_code_lines[-2] += this.root_code_lines[-1]

                    // }
                    saved_lines += 1
                }


            }
            //     if(word.x == above_code_lines_dots.x){

            //     }
            // //     if(last_y_in_root_code !== word.y){

            // //         this.root_code_lines[root_lines_no] = []
            // //         this.root_code_lines[root_lines_no].push(this.decodeText(word.text))
            // //         last_y_in_root_code = word.y

            // //     }else{
            // //         this.root_code_lines[root_lines_no-1].push(this.decodeText(word.text))
            // //     }

            // }

            if (word.y >= rows_ranges[0][0] && word.y < rows_ranges[0][1] && word.text != "Archivo") { // obtiene palabras en la fila de "ARchivo"
                if (word.x >= columns_ranges[0][0] && word.x < columns_ranges[0][1]) {
                    this.root_file.push(this.decodeText(word.text))
                }
                else {
                    this.affected_file.push(this.decodeText(word.text))
                }
            }

            if (word.y >= rows_ranges[1][0] && word.y < rows_ranges[1][1] && word.text != "L%C3%ADnea") { // obtiene palabras en la linea "Linea"
                if (word.x >= columns_ranges[0][0] && word.x < columns_ranges[0][1]) {
                    this.root_line.push(this.decodeText(word.text))
                } else {
                    this.affected_line.push(this.decodeText(word.text))
                }
            }

            if (word.y >= rows_ranges[2][0] && word.y < rows_ranges[2][1] && word.text != "Objeto") { // obtener palabras en la linea Objeto
                if (word.x >= columns_ranges[0][0] && word.x < columns_ranges[0][1]) {
                    this.root_object.push(this.decodeText(word.text))
                } else {
                    this.affected_object.push(this.decodeText(word.text))
                }
            }
        })


        // console.log('code lines',this.root_code_lines.length)
    }


    // async set_vul_type(){
    //     this.vul_dir = await fsPromises.readFile(this.vul_dir_path)

    //     this.vul_dir = JSON.parse(this.vul_dir)
    //     let vul_names = Object.keys(this.vul_dir)

    //     if(vul_names.includes(this.vul_name)){
    //         this.type_no = this.vul_dir[this.vul_name]
    //     }else{
    //         this.vul_dir[this.vul_name] = vul_names.length
    //         this.type_no = vul_names.length
    //         await fsPromises.writeFile('./utils/vul_directory.json',JSON.stringify(this.vul_dir))
    //     }
    // }



    // this object finds the text in the same line than a defined word
    found_text_in_same_row(refrence_word, exclude_first = undefined, stop_text = undefined) { // reference word
        let found_text = []
        
        


        if (exclude_first === true) {
            let skiped = false
            if (!stop_text != true) {
                let ind_x = []
                this.word_arr.forEach((word, index) => {
                    if((word.text == refrence_word.text) || (word.text == stop_text)){
                        ind_x.push(index)
                    } 
                })
                for (let i = ind_x[0]; i < ind_x[1]; i++) {
                    (skiped) ? found_text.push(decodeURI(this.word_arr[i].text)):skiped = true
                    
                }
            } else {
                
                this.word_arr.forEach(word => {
                    
                    if (word.y === refrence_word.y) {
                        (skiped) ? found_text.push(decodeURI(word.text)) : skiped = true;
                    }
                })
            }
        } else {

            this.word_arr.forEach(word => {
                if (word.y === refrence_word.y) found_text.push(decodeURI(word.text));
            })
        }
        
        
        return found_text.join('_')
    }
    
    format_vul_name() { // formats the vul name
        this.vul_name = this.vul_name.split('\\')[0].toString()
    }

    decodeText(text) {
        return decodeURI(text)
    }

}

export default Vulnerability